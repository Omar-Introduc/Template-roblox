import bpy
import math
import random

def clear_scene():
    """Elimina todos los objetos de la escena para comenzar desde cero."""

def create_gem_material(name, color_hex):
    """Crea un material con propiedades de emisión compatibles con Blender 3.6 y 4.0+."""
    mat = bpy.data.materials.new(name=name)
    mat.use_nodes = True
    nodes = mat.node_tree.nodes
    nodes.clear()
    
    node_bsdf = nodes.new(type='ShaderNodeBsdfPrincipled')
    
    # Conversión de Hex a RGB
    hex_val = color_hex.lstrip('#')
    rgb = tuple(int(hex_val[i:i+2], 16)/255.0 for i in (0, 2, 4))
    
    node_bsdf.inputs['Base Color'].default_value = (*rgb, 1.0)
    
    # Soporte para Emission (Blender 4.0 cambió los nombres de los sockets)
    emission_col = node_bsdf.inputs.get('Emission Color') or node_bsdf.inputs.get('Emission')
    if emission_col:
        emission_col.default_value = (*rgb, 1.0)
    
    strength = node_bsdf.inputs.get('Emission Strength')
    if strength:
        strength.default_value = 1.2
        
    transmission = node_bsdf.inputs.get('Transmission Weight') or node_bsdf.inputs.get('Transmission')
    if transmission:
        transmission.default_value = 0.5
        
    node_bsdf.inputs['Roughness'].default_value = 0.1
    node_bsdf.inputs['Metallic'].default_value = 0.8
    
    node_output = nodes.new(type='ShaderNodeOutputMaterial')
    mat.node_tree.links.new(node_bsdf.outputs['BSDF'], node_output.inputs['Surface'])
    
    return mat

def create_custom_mesh(name, verts, faces, location):
    """Crea una malla manualmente desde vértices y caras (Evita depender de Add-ons)."""
    mesh = bpy.data.meshes.new(name)
    obj = bpy.data.objects.new(name, mesh)
    bpy.context.collection.objects.link(obj)
    mesh.from_pydata(verts, [], faces)
    mesh.update()
    obj.location = location
    return obj

def animate_floating_and_rotation(obj, start_frame, end_frame, rot_speed):
    """Genera la animación de flotación y rotación por fotogramas."""
    for frame in range(start_frame, end_frame + 1):
        t = (frame - start_frame) / 20.0
        
        # Flotación en Z
        obj.location.z += math.sin(t * 1.5) * 0.005
        obj.keyframe_insert(data_path="location", frame=frame)
        
        # Rotación en Z
        obj.rotation_euler.z += rot_speed
        obj.keyframe_insert(data_path="rotation_euler", frame=frame)

def run_generator():
    """Función maestra que construye toda la escena."""
    clear_scene()
    
    scene = bpy.context.scene
    scene.frame_start = 1
    scene.frame_end = 250
    scene.render.fps = 60

    gems_config = [
        {"name": "Esmeralda", "color": "#22ff44", "loc": (-6, 0, 1)},
        {"name": "Rubi", "color": "#ff0044", "loc": (-3, 0, 1)},
        {"name": "Zafiro", "color": "#0088ff", "loc": (0, 0, 1)},
        {"name": "Cuarzo", "color": "#ffffff", "loc": (3, 0, 1)},
        {"name": "Caos", "color": "#aa00ff", "loc": (6, 0, 1)}
    ]

    # --- 1. ESMERALDA (Cilindro 8 caras) ---
    mat_e = create_gem_material("Mat_Emerald", gems_config[0]["color"])
    bpy.ops.mesh.primitive_cylinder_add(vertices=8, radius=0.8, depth=2, location=gems_config[0]["loc"])
    e_obj = bpy.context.active_object
    e_obj.data.materials.append(mat_e)
    animate_floating_and_rotation(e_obj, 1, 250, 0.02)

    # --- 2. RUBÍ (Octaedro manual) ---
    mat_r = create_gem_material("Mat_Ruby", gems_config[1]["color"])
    v_octa = [(0, 0, 1), (0, 0, -1), (1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0)]
    f_octa = [(0,2,4), (0,4,3), (0,3,5), (0,5,2), (1,4,2), (1,3,4), (1,5,3), (1,2,5)]
    r_obj = create_custom_mesh("Rubi", v_octa, f_octa, gems_config[1]["loc"])
    r_obj.scale = (1.0, 1.0, 1.4)
    r_obj.data.materials.append(mat_r)
    animate_floating_and_rotation(r_obj, 1, 250, 0.05)

    # --- 3. ZAFIRO (Unión de dos conos/cilindros hexagonales) ---
    mat_z = create_gem_material("Mat_Sapphire", gems_config[2]["color"])
    bpy.ops.mesh.primitive_cylinder_add(vertices=6, radius=1.0, depth=1.2, location=(gems_config[2]["loc"][0], 0, 1.6))
    z_top = bpy.context.active_object
    bpy.ops.mesh.primitive_cylinder_add(vertices=6, radius=1.0, depth=1.2, location=(gems_config[2]["loc"][0], 0, 0.4))
    z_bottom = bpy.context.active_object
    
    bpy.ops.object.select_all(action='DESELECT')
    z_top.select_set(True)
    z_bottom.select_set(True)
    bpy.context.view_layer.objects.active = z_top
    bpy.ops.object.join()
    z_obj = bpy.context.active_object
    z_obj.name = "Zafiro"
    z_obj.data.materials.append(mat_z)
    animate_floating_and_rotation(z_obj, 1, 250, 0.03)

    # --- 4. CUARZO (Parent + Cilindros) ---
    mat_q = create_gem_material("Mat_Quartz", gems_config[3]["color"])
    q_parent = bpy.data.objects.new("Cuarzo_Group", None)
    q_parent.location = gems_config[3]["loc"]
    scene.collection.objects.link(q_parent)
    for _ in range(7):
        bpy.ops.mesh.primitive_cylinder_add(vertices=5, radius=0.2, depth=1 + random.random())
        c = bpy.context.active_object
        c.parent = q_parent
        c.location = (random.uniform(-0.6, 0.6), random.uniform(-0.6, 0.6), random.uniform(-0.2, 0.2))
        c.rotation_euler = (random.random(), random.random(), random.random())
        c.data.materials.append(mat_q)
    animate_floating_and_rotation(q_parent, 1, 250, 0.01)

    # --- 5. CAOS (Icosfera + Tetraedros manuales) ---
    mat_c = create_gem_material("Mat_Chaos", gems_config[4]["color"])
    bpy.ops.mesh.primitive_ico_sphere_add(subdivisions=0, radius=0.8, location=gems_config[4]["loc"])
    c_core = bpy.context.active_object
    c_core.data.materials.append(mat_c)
    animate_floating_and_rotation(c_core, 1, 250, 0.02)

    # Vértices y caras de un Tetraedro para los fragmentos
    v_tetra = [(1, 1, 1), (1, -1, -1), (-1, 1, -1), (-1, -1, 1)]
    f_tetra = [(0, 1, 2), (0, 2, 3), (0, 3, 1), (1, 3, 2)]

    for i in range(8):
        shard = create_custom_mesh(f"Shard_{i}", v_tetra, f_tetra, (0,0,0))
        shard.scale = (0.2, 0.2, 0.2)
        shard.data.materials.append(mat_c)
        offset = (i / 8) * math.pi * 2
        for frame in range(1, 251):
            t = frame / 20.0
            angle = t * 1.5 + offset
            shard.location.x = gems_config[4]["loc"][0] + math.cos(angle) * 1.8
            shard.location.y = gems_config[4]["loc"][1] + math.sin(angle) * 1.8
            shard.location.z = gems_config[4]["loc"][2] + math.sin(t * 2 + offset) * 0.4
            shard.rotation_euler.x += 0.05
            shard.rotation_euler.y += 0.05
            shard.keyframe_insert(data_path="location", frame=frame)
            shard.keyframe_insert(data_path="rotation_euler", frame=frame)

    # Shading Low Poly Final
    for obj in bpy.data.objects:
        if obj.type == 'MESH':
            for poly in obj.data.polygons:
                poly.use_smooth = False

    try:
        for area in bpy.context.screen.areas:
            if area.type == 'OUTLINER':
                area.tag_redraw()
    except:
        pass

if __name__ == "__main__":
    run_generator()